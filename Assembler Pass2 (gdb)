#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINES 100
#define MAX_LEN 50

typedef struct {
    char label[MAX_LEN];
    int address;
    char value[MAX_LEN];
} Symbol;

Symbol symtab[MAX_LINES];
int symCount = 0;

int findSymbol(char *label) {
    for (int i = 0; i < symCount; i++) {
        if (strcmp(symtab[i].label, label) == 0) {
            return symtab[i].address;
        }
    }
    return -1;
}

void addSymbol(char *label, int address, char *value) {
    strcpy(symtab[symCount].label, label);
    symtab[symCount].address = address;
    strcpy(symtab[symCount].value, value);
    symCount++;
}

void pass2(FILE *input) {
    char line[MAX_LEN], opcode[MAX_LEN], operand1[MAX_LEN], operand2[MAX_LEN];
    int lc = 0;
    
    while (fgets(line, sizeof(line), input)) {
        if (sscanf(line, "%s %s %s", opcode, operand1, operand2) >= 1) {
            if (strcmp(opcode, "START") == 0 || strcmp(opcode, "END") == 0) {
                continue;
            }
            else if (strcmp(opcode, "MOVER") == 0 || strcmp(opcode, "STORE") == 0) {
                int addr = findSymbol(operand2);
                if (addr != -1) {
                    printf("%d: %s %s %d\n", lc, opcode, operand1, addr);
                } else {
                    printf("%d: %s %s %s\n", lc, opcode, operand1, operand2);
                }
            }
            else if (strcmp(opcode, "ADD") == 0) {
                printf("%d: ADD\n", lc);
            }
            else if (strcmp(opcode, "DS") == 0 || strcmp(opcode, "DC") == 0) {
                addSymbol(operand1, lc, operand2);
            }
            lc++;
        }
    }
}

int main() {
    FILE *input = fopen("ir.dat", "r");
    if (!input) {
        printf("Error opening file ir.dat\n");
        return 1;
    }
    pass2(input);
    fclose(input);
    return 0;
}

# ir.dat

AD1C100
IS51S0
IS61S1
IS21L0
IS31L1
IS61S0
DL15
DL23
AD2C1
AD2C2
